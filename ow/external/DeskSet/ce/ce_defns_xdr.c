/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

/* This file has been edited to change the recursive read/write algorithms
   to be sequential. This was done so that the run-time stacks are not 
   large.So rpcgen is no longer used to generate this file.
*/

#include <rpc/rpc.h>
#include "ce_defns.h"


/* This file was created from "ce_defns.x" by RPCGEN. Only "ce_defns.x"
 * should be modified
 */


bool_t
xdr_CE_ATTR(xdrs, objp)
	XDR *xdrs;
	CE_ATTR *objp;
{
	if (!xdr_string(xdrs, &objp->a_name, ~0)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->a_id)) {
		return (FALSE);
	}
	if (!xdr_short(xdrs, &objp->db_id)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->flags)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_attr_list(xdrs, objp)
	XDR *xdrs;
	attr_list *objp;
{
	bool_t	more_data;
	attr_list  *nextp;
	
	for(;;) {
		more_data = (*objp != NULL);

		if(!xdr_bool(xdrs, &more_data)) {
			return(FALSE);
		}
		if(!more_data) {
			break;
		}
		if(xdrs->x_op == XDR_FREE) {
			nextp = &(*objp)->next_attr;
		}
		if(!xdr_reference(xdrs, (char **)objp, 
					sizeof(CE_ATTR),xdr_CE_ATTR)) {
			return(FALSE);
		}
		objp = (xdrs->x_op == XDR_FREE) ?
			nextp : &(*objp)->next_attr;
        }
	
	*objp = NULL;
	return(TRUE);
}
	

bool_t
xdr_CE_AV(xdrs, objp)
	XDR *xdrs;
	CE_AV *objp;
{
	if (!xdr_string(xdrs, &objp->a_id, ~0)) {
		return (FALSE);
	}
	if (!xdr_string(xdrs, &objp->a_type, ~0)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->a_size)) {
		return (FALSE);
	}
	if (!xdr_string(xdrs, &objp->a_val, ~0)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->flags)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&objp->old_info, sizeof(OLD_INFO), xdr_OLD_INFO)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_av_list(xdrs, objp)
	XDR *xdrs;
	av_list *objp;
{
	bool_t	more_data;
	av_list  *nextp;
	
	for(;;) {
		more_data = (*objp != NULL);

		if(!xdr_bool(xdrs, &more_data)) {
			return(FALSE);
		}
		if(!more_data) {
			break;
		}
		if(xdrs->x_op == XDR_FREE) {
			nextp = &(*objp)->next_av;
		}
		if(!xdr_reference(xdrs, (char **)objp, 
					sizeof(CE_AV),xdr_CE_AV)) {
			return(FALSE);
		}
		objp = (xdrs->x_op == XDR_FREE) ?
			nextp : &(*objp)->next_av;
        }
	
	*objp = NULL;
	return(TRUE);
}
	

bool_t
xdr_CE_ENT(xdrs, objp)
	XDR *xdrs;
	CE_ENT *objp;
{
	if (!xdr_int(xdrs, &objp->ent_id)) {
		return (FALSE);
	}
	if (!xdr_short(xdrs, &objp->db_id)) {
		return (FALSE);
	}
	if (!xdr_av_list(xdrs, &objp->avs)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->match_size)) {
		return (FALSE);
	}
	if (!xdr_bytes(xdrs, (char **)&objp->match_vals.match_vals_val, (u_int *)&objp->match_vals.match_vals_len, ~0)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->flags)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_entry_list(xdrs, objp)
	XDR *xdrs;
	entry_list *objp;
{
	bool_t	more_data;
	entry_list  *nextp;
	
	for(;;) {
		more_data = (*objp != NULL);

		if(!xdr_bool(xdrs, &more_data)) {
			return(FALSE);
		}
		if(!more_data) {
			break;
		}
		if(xdrs->x_op == XDR_FREE) {
			nextp = &(*objp)->next_entry;
		}
		if(!xdr_reference(xdrs, (char **)objp, 
					sizeof(CE_ENT),xdr_CE_ENT)) {
			return(FALSE);
		}
		objp = (xdrs->x_op == XDR_FREE) ?
			nextp : &(*objp)->next_entry;
        }
	
	*objp = NULL;
	return(TRUE);
}
	

bool_t
xdr_CE_NS(xdrs, objp)
	XDR *xdrs;
	CE_NS *objp;
{
	if (!xdr_string(xdrs, &objp->ns_name, ~0)) {
		return (FALSE);
	}
	if (!xdr_short(xdrs, &objp->db_id)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->num_attrs)) {
		return (FALSE);
	}
	if (!xdr_attr_list(xdrs, &objp->attr_def)) {
		return (FALSE);
	}
	if (!xdr_attr_list(xdrs, &objp->rt_list)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->num_ents)) {
		return (FALSE);
	}
	if (!xdr_entry_list(xdrs, &objp->entries)) {
		return (FALSE);
	}
	if (!xdr_pointer(xdrs, (char **)&objp->ns_mgr_ptr, sizeof(NS_MGR_INFO), xdr_NS_MGR_INFO)) {
		return (FALSE);
	}
	if (!xdr_u_int(xdrs, &objp->flags)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ns_list(xdrs, objp)
	XDR *xdrs;
	ns_list *objp;
{
	bool_t	more_data;
	ns_list  *nextp;
	
	for(;;) {
		more_data = (*objp != NULL);

		if(!xdr_bool(xdrs, &more_data)) {
			return(FALSE);
		}
		if(!more_data) {
			break;
		}
		if(xdrs->x_op == XDR_FREE) {
			nextp = &(*objp)->next_ns;
		}
		if(!xdr_reference(xdrs, (char **)objp, 
					sizeof(CE_NS),xdr_CE_NS)) {
			return(FALSE);
		}
		objp = (xdrs->x_op == XDR_FREE) ?
			nextp : &(*objp)->next_ns;
        }
	
	*objp = NULL;
	return(TRUE);
}

bool_t
xdr_CE_DB(xdrs, objp)
	XDR *xdrs;
	CE_DB *objp;
{
	if (!xdr_string(xdrs, &objp->db_name, ~0)) {
		return (FALSE);
	}
	if (!xdr_string(xdrs, &objp->db_path, ~0)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->dd)) {
		return (FALSE);
	}
	if (!xdr_int(xdrs, &objp->num_ns)) {
		return (FALSE);
	}
	if (!xdr_ns_list(xdrs, &objp->namespaces)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_ce_db_p(xdrs, objp)
	XDR *xdrs;
	ce_db_p *objp;
{
	if (!xdr_pointer(xdrs, (char **)objp, sizeof(CE_DB), xdr_CE_DB)) {
		return (FALSE);
	}
	return (TRUE);
}
