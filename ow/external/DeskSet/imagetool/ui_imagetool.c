
#ifndef lint
static char sccsid[] = "@(#)ui_imagetool.c 1.68 95/03/01";
#endif

/*
 * Copyright (c) 1986, 1987, 1988 by Sun Microsystems, Inc.
 */

/*
 * ui_imagetool.c - User interface object initialization functions.
 * This file was generated by `gxv' from `imagetool.G'.
 */

#include <sys/param.h>
#include <xview/xview.h>
#include <xview/canvas.h>
#include <xview/cms.h>
#include <xview/cursor.h>
#include <xview/dragdrop.h>
#include <xview/notice.h>
#include <xview/panel.h>
#include <xview/scrollbar.h>
#include <xview/svrimage.h>
#include <xview/textsw.h>
#include "display.h"
#include "image.h"
#include "props.h"
#include "imagetool.h"
#include "ui_imagetool.h"

#define	DPS_EXTENSION	"Adobe-DPS-Extension"

Pixmap stipple_pixmap = NULL;

static int panel_x_gap;
static int panel_y_gap;
static int panel_gap;
static int small_panel_gap;

int    scroll_width;
int    scroll_height;
Cms    panel_cms;
Visual *panel_visual;

/*
 * Create XViewInfo object that will store the defaults for this
 * application.
 * Should we be reading from xdefaults to get geometry size, etc?
 */

XviewInfo *
init_xview ()
{
    XviewInfo	*xv_defaults;

    xv_defaults = (XviewInfo *) calloc (1, sizeof (XviewInfo));

    xv_defaults->frame_label_set = FALSE;
    xv_defaults->frame_label = (char *) NULL;
    xv_defaults->icon_label_set = FALSE;
    xv_defaults->icon_label = (char *) NULL;
    xv_defaults->geometry_set = FALSE;
    xv_defaults->depth_set = FALSE;
    xv_defaults->depth = 0;
    xv_defaults->visual_set = FALSE;
    xv_defaults->visual = 0;
   
    return (xv_defaults);
}

/*
 * Create object `file_menu' in the specified instance.
 */
Xv_opaque
base_window_file_menu_create (ip, owner)
	caddr_t		ip;
	Xv_opaque	owner;
{
	extern Menu_item	open_callback();
	extern Menu_item	openas_callback();
	extern Menu_item	save_callback();
	extern Menu_item	saveas_callback();
	extern Menu_item	print_preview_callback();
	extern Menu_item	print_one_callback();
	extern Menu_item	print_callback();
	Xv_opaque		obj;
	
	obj = xv_create(XV_NULL, MENU_COMMAND_MENU,
		XV_KEY_DATA, INSTANCE, ip,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Open..."),
#ifdef KYBDACC
			MENU_ACCELERATOR, DGET ("coreset Open"),
#endif
			MENU_GEN_PROC, open_callback,
			XV_HELP_DATA, "imagetool:Open",
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Open As..."),
			MENU_GEN_PROC, openas_callback,
			XV_HELP_DATA, "imagetool:OpenAs",
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, "",
			MENU_FEEDBACK, FALSE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
#ifdef FILECHOOSER
			MENU_STRING, LGET ("Save..."),
#else
			MENU_STRING, LGET ("Save"),
#endif
#ifdef KYBDACC
			MENU_ACCELERATOR, DGET ("coreset Save"),
#endif
			MENU_GEN_PROC, save_callback,
			XV_HELP_DATA, "imagetool:Save",
			MENU_INACTIVE, TRUE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Save As..."),
			MENU_GEN_PROC, saveas_callback,
			XV_HELP_DATA, "imagetool:SaveAs",
			MENU_INACTIVE, TRUE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Save Selection As..."),
			MENU_INACTIVE, TRUE,
			MENU_GEN_PROC, saveas_callback,
			XV_HELP_DATA, "imagetool:SaveSelectionAs",
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Save Page As Image..."),
			MENU_INACTIVE, TRUE,
			MENU_GEN_PROC, saveas_callback,
			XV_HELP_DATA, "imagetool:SavePageAsImage",
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, "",
			MENU_FEEDBACK, FALSE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Print One"),
			MENU_INACTIVE, TRUE,
#ifdef KYBDACC
			MENU_ACCELERATOR, DGET ("coreset Print"),
#endif
			MENU_GEN_PROC, print_one_callback,
			XV_HELP_DATA, "imagetool:PrintOne",
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Print Preview..."),
			MENU_INACTIVE, TRUE,
			MENU_GEN_PROC, print_preview_callback,
			XV_HELP_DATA, "imagetool:PrintPreview",
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Print..."),
			MENU_INACTIVE, TRUE,
			MENU_GEN_PROC, print_callback,
			XV_HELP_DATA, "imagetool:Print",
			NULL,
		NULL);

/*
 * Set the Open option inactive if CE not
 * initialized properly.  
 */
/* No longer doing this because not init'ing CE in main().
       if (!prog->ce_okay)
         xv_set (xv_get (obj, MENU_NTH_ITEM, OPENFC),
	         MENU_INACTIVE,	TRUE,
	         NULL);
*/
        
	return obj;
}

/*
 * Create object `edit_menu' in the specified instance.
 */
Xv_opaque
base_window_edit_menu_create(ip, owner)
	caddr_t		ip;
	Xv_opaque	owner;
{
	Xv_opaque		obj;
        extern Menu_item        undo_callback();
	extern Menu_item	props_callback();
	extern Menu_item	palette_callback ();
	
	obj = xv_create(XV_NULL, MENU_COMMAND_MENU,
		XV_KEY_DATA, INSTANCE, ip,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Undo"),
			MENU_NOTIFY_PROC, undo_callback,
#ifdef KYBDACC
			MENU_ACCELERATOR, DGET ("coreset Undo"),
#endif
			XV_HELP_DATA, "imagetool:Undo",
			MENU_INACTIVE, TRUE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, "",
			MENU_FEEDBACK, FALSE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Palette..."),
			MENU_GEN_PROC, palette_callback,
			XV_HELP_DATA, "imagetool:Palette",
			MENU_INACTIVE, TRUE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Properties..."),
#ifdef KYBDACC
			MENU_ACCELERATOR, DGET ("coreset Props"),
#endif
			MENU_GEN_PROC, props_callback,
			XV_HELP_DATA, "imagetool:Properties",
			NULL,
		NULL);
	return obj;
}

/*
 * Create object `view_menu' in the specified instance.
 */
Xv_opaque
base_window_view_menu_create(ip, owner)
	caddr_t		ip;
	Xv_opaque	owner;
{
	extern Menu_item	imageinfo_callback ();
	extern Menu_item	pageview_callback ();
	extern Menu_item	ps_options_callback();
	Xv_opaque		obj;
	
	obj = xv_create(XV_NULL, MENU_COMMAND_MENU,
		XV_KEY_DATA, INSTANCE, ip,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Image Info..."),
			MENU_GEN_PROC, imageinfo_callback,
			XV_HELP_DATA, "imagetool:ImageInfo",
			MENU_INACTIVE, TRUE,
			NULL,
                MENU_ITEM,
                        XV_KEY_DATA, INSTANCE, ip,
                        MENU_STRING, "",
                        MENU_FEEDBACK, FALSE,
                        NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Page Overview..."),
			MENU_GEN_PROC, pageview_callback,
			XV_HELP_DATA, "imagetool:Pageview",
			MENU_INACTIVE, TRUE,
			NULL,
		MENU_ITEM,
			XV_KEY_DATA, INSTANCE, ip,
			MENU_STRING, LGET ("Page Viewing Controls..."),
			XV_HELP_DATA, "imagetool:PsOptions",
			MENU_INACTIVE, TRUE,
			MENU_GEN_PROC, ps_options_callback,
			NULL,
		NULL);
	return obj;
}

/*
 * Initialize an instance of object `base_window'.
 */
BaseWindowObjects *
BaseWindowObjectsInitialize(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque		 owner;
{
        int  height;
        int  item_height;
	extern Notify_value	imagetool_done_proc ();

	if (!ip && 
	    !(ip = (BaseWindowObjects *) calloc(1, sizeof (BaseWindowObjects))))
		return (BaseWindowObjects *) NULL;
	if (!ip->base_window)
		ip->base_window = base_window_base_window_create(ip, owner);
	if (!ip->base_panel)
		ip->base_panel = base_window_base_panel_create(ip, 
							       ip->base_window);
	if (!ip->file_menu)
		ip->file_menu = base_window_file_menu_create (ip, 
							      ip->base_window);
	if (!ip->file_button)
		ip->file_button = base_window_file_button_create(ip, 
							ip->base_panel);
	if (!ip->view_menu)
		ip->view_menu = base_window_view_menu_create (ip, 
							      ip->base_window);
	if (!ip->view_button)
		ip->view_button = base_window_view_button_create(ip, 
							ip->base_panel);
	if (!ip->edit_menu)
		ip->edit_menu = base_window_edit_menu_create (ip, 
							      ip->base_window);
	 if (!ip->edit_button)
		ip->edit_button = base_window_edit_button_create(ip, 
							ip->base_panel);
	if (!ip->help_button)
		ip->help_button = base_window_help_button_create(ip, 
							ip->base_panel);
	if (!ip->page_backward_button)
		ip->page_backward_button = 
		    base_window_page_backward_button_create(ip, ip->base_panel);
	if (!ip->page_forward_button)
		ip->page_forward_button = 
		     base_window_page_forward_button_create(ip, ip->base_panel);
	if (!ip->dragdrop)
		ip->dragdrop = base_window_dragdrop_create(ip, 
							ip->base_panel);
	if (!ip->drop_target)
		ip->drop_target = base_window_drop_target_create(ip, 
							ip->base_panel);

	if (xview_info->frame_label_set == TRUE)
	   xv_set (ip->base_window, FRAME_LABEL, xview_info->frame_label, NULL);

	if (xview_info->icon_label_set == TRUE)
    	   set_icon_label (ip, xview_info->icon_label);
/*
 * Set the panel height now that we created the buttons and
 * drop target.
 */
        height = Max (xv_get (ip->file_button, XV_HEIGHT), 
		      xv_get (ip->drop_target, XV_HEIGHT));

        height = Max (height, xv_get (ip->page_forward_button, XV_HEIGHT)) + 10;
        xv_set (ip->base_panel, XV_HEIGHT, height, NULL);

/* 
 * Position the buttons and drop target 
 */

	item_height = xv_get (ip->file_button, XV_HEIGHT);
	xv_set (ip->file_button, XV_Y, (height - item_height) / 2,
				 NULL);

	item_height = xv_get (ip->view_button, XV_HEIGHT);
	xv_set (ip->view_button, XV_Y, (height - item_height) / 2,
				 NULL);

	item_height = xv_get (ip->edit_button, XV_HEIGHT);
	xv_set (ip->edit_button, XV_Y, (height - item_height) / 2,
				 NULL);

	item_height = xv_get (ip->help_button, XV_HEIGHT);
	xv_set (ip->help_button, XV_Y, (height - item_height) / 2,
				 NULL);

	item_height = xv_get (ip->page_forward_button, XV_HEIGHT);
	xv_set (ip->page_forward_button, XV_Y, (height - item_height) / 2,
				 NULL);

	item_height = xv_get (ip->page_backward_button, XV_HEIGHT);
	xv_set (ip->page_backward_button, XV_Y, (height - item_height) / 2,
				 NULL);

	item_height = xv_get (ip->drop_target, XV_HEIGHT);
	xv_set (ip->drop_target, XV_Y, (height - item_height) / 2,
				 NULL);

/*
 * Set the minimum size of the frame.
 * min_width = room for all buttons + drop target;
 * min_height = panel_height + 12 pixels for canvas;
 */
        /*ip->min_size.r_width = xv_get (ip->page_forward_button, XV_X) +
                                 xv_get (ip->page_forward_button, XV_WIDTH) + 
				 30 + xv_get (ip->drop_target, XV_WIDTH) + 10; */

	ip->min_size.r_width = xv_get (ip->drop_target, XV_X) +
			       xv_get (ip->drop_target, XV_WIDTH); + 10; 
	ip->min_size.r_height = xv_get (ip->base_panel, XV_HEIGHT) + 12;
        xv_set (ip->base_window, FRAME_MIN_SIZE, 
		ip->min_size.r_width, ip->min_size.r_height, NULL);

	if (xv_get (ip->base_window, XV_WIDTH) < ip->min_size.r_width)
	   xv_set (ip->base_window,  XV_WIDTH, ip->min_size.r_width, NULL);

/*
 * Bind menus to frame for the accelerators
 */

#ifdef KYBDACC
        xv_set (ip->base_window, FRAME_MENU_ADD, ip->file_menu, NULL);
        xv_set (ip->base_window, FRAME_MENU_ADD, ip->edit_menu, NULL);
#endif

/*
 * Interpose on the quit function so we can tell snapshot (if we were
 * started via tooltalk).
 */

  	notify_interpose_destroy_func (ip->base_window, imagetool_done_proc);

	return (ip);
}

void
base_window_image_canvas_objects_create (ip)
	BaseWindowObjects	*ip;
{
	int   frame_width, frame_height;
	int   panel_height;

	if (!ip->canvas)
		ip->canvas = base_window_canvas_create(ip, ip->base_window);
	if (!ip->hscroll)
		ip->hscroll = base_window_hscroll_create (ip, ip->canvas);
	if (!ip->vscroll)
		ip->vscroll = base_window_vscroll_create (ip, ip->canvas);

        frame_width  = xv_get (ip->base_window, XV_WIDTH);
        frame_height = xv_get (ip->base_window, XV_HEIGHT);
        panel_height = xv_get (ip->base_panel, XV_HEIGHT);

        xv_set (ip->canvas, 
	 	CANVAS_HEIGHT, frame_height - panel_height - scroll_height,
		CANVAS_WIDTH, frame_width - scroll_width,
		NULL);

}

void
base_window_ps_canvas_objects_create (ip)
	BaseWindowObjects	*ip;
{
	int   frame_width, frame_height;
	int   panel_height;

	if (!ip->ps_canvas)
		ip->ps_canvas = base_window_ps_canvas_create(ip, 
							     ip->base_window);
	if (!ip->ps_hscroll)
		ip->ps_hscroll = base_window_ps_hscroll_create
					(ip, ip->ps_canvas);
	if (!ip->ps_vscroll)
		ip->ps_vscroll = base_window_ps_vscroll_create
					(ip, ip->ps_canvas);

        frame_width  = xv_get (ip->base_window, XV_WIDTH);
        frame_height = xv_get (ip->base_window, XV_HEIGHT);
        panel_height = xv_get (ip->base_panel, XV_HEIGHT);

        xv_set (ip->ps_canvas, 
	 	CANVAS_HEIGHT, frame_height - panel_height - scroll_height,
		CANVAS_WIDTH, frame_width - scroll_width,
		NULL);

}

/*
 * Create object `base_window' in the specified instance.
 */
Xv_opaque
base_window_base_window_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque		 owner;
{
	Xv_opaque	obj;
	Rect		rect2;
	Xv_opaque	obj2;
	Xv_opaque	obj3;
	static unsigned short icon_bits [] = {
#include "im.icon"
	};
	static unsigned short mask_bits [] = {
#include "imask.icon"
	};
	Server_image	    icon_image;
	Server_image	    mask_image;
	Icon		    im_icon;
        Rect               *rect;
	extern Notify_value base_window_event_proc ();
	
	icon_image = (Server_image) xv_create(NULL, SERVER_IMAGE,
                                          XV_WIDTH, 64,
                                          XV_HEIGHT, 64,
                                          SERVER_IMAGE_DEPTH, 1,
                                          SERVER_IMAGE_BITS, icon_bits,
                                          NULL);

	mask_image = (Server_image) xv_create(NULL, SERVER_IMAGE,
                                          XV_WIDTH, 64,
                                          XV_HEIGHT, 64,
                                          SERVER_IMAGE_DEPTH, 1,
                                          SERVER_IMAGE_BITS, mask_bits,
                                          NULL);

	im_icon = (Icon) xv_create(NULL, ICON,
                            ICON_IMAGE, icon_image,
                            ICON_MASK_IMAGE, mask_image,
                            ICON_TRANSPARENT, TRUE,
                            WIN_RETAINED, TRUE,
                            NULL);

        if (xview_info->geometry_set) 
  	  obj = xv_create(owner, FRAME,
		  XV_KEY_DATA, INSTANCE, ip,
		  FRAME_SHOW_FOOTER, TRUE,
		  FRAME_SHOW_RESIZE_CORNER, TRUE,
		  FRAME_ICON, im_icon,
#ifdef OW_I18N
		  WIN_USE_IM, FALSE,
#endif
		  WIN_CONSUME_X_EVENT_MASK,
                        VisibilityChangeMask | ButtonPressMask |
                        ButtonReleaseMask | Button1MotionMask,
		  NULL);
	else
  	  obj = xv_create(owner, FRAME,
		  XV_KEY_DATA, INSTANCE, ip,
		  XV_WIDTH, 534,
		  XV_HEIGHT, 650,
		  WIN_USE_IM, FALSE,
		  FRAME_SHOW_FOOTER, TRUE,
		  FRAME_SHOW_RESIZE_CORNER, TRUE,
		  FRAME_ICON, im_icon,
		  WIN_CONSUME_X_EVENT_MASK,
                        VisibilityChangeMask | ButtonPressMask |
                        ButtonReleaseMask | Button1MotionMask,
		  NULL);

	notify_interpose_event_func ((Notify_client) obj,
				     (Notify_func) base_window_event_proc,
				     NOTIFY_SAFE);
	notify_interpose_event_func ((Notify_client) obj,
				     (Notify_func) base_window_event_proc,
				     NOTIFY_IMMEDIATE);

	ps_display = (DisplayInfo *) calloc (1, sizeof (DisplayInfo));
        image_display = (DisplayInfo *) calloc (1, sizeof (DisplayInfo));
	image_display->xdisplay = (Display *) xv_get (obj, XV_DISPLAY);

/*
 * Set Max size of frame when opening file only.
 * Note.. changed to 50, since 25 didn't seem to work (still was larger
 * 	than the window).
 */
	rect = (Rect *) xv_get (obj, WIN_SCREEN_RECT);
	ip->max_size.r_width = rect->r_width - 50;
	ip->max_size.r_height = rect->r_height - 50;

	obj2 = xv_create (obj, DROP_SITE_ITEM,
                            DROP_SITE_DEFAULT,          TRUE,
                            DROP_SITE_ID,               1,
                            DROP_SITE_EVENT_MASK, DND_MOTION | DND_ENTERLEAVE,
                            0);
 
	rect2.r_left = 0;
	rect2.r_top = 0;
	rect2.r_width = xv_get (obj, XV_WIDTH);
	rect2.r_height = xv_get (obj, XV_HEIGHT);
 
	xv_set (obj2,
                  DROP_SITE_DELETE_REGION, NULL,
                  DROP_SITE_REGION,        &rect2,
                  0);

	obj3 = xv_create (obj, SELECTION_REQUESTOR, 0);
	
	xv_set (obj, XV_KEY_DATA, DROPSITE, obj2,
		     XV_KEY_DATA, SELECTOR, obj3,
		     NULL);

	return obj;
}

/*
 * Create object `base_panel' in the specified instance.
 */
Xv_opaque
base_window_base_panel_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, 0,
		XV_WIDTH, WIN_EXTEND_TO_EDGE,
		WIN_BORDER, FALSE,
		PANEL_ACCEPT_KEYSTROKE, TRUE,
		XV_HELP_DATA, "imagetool:Panel",
		NULL);

	panel_cms = (Cms) xv_get (obj, WIN_CMS);
	panel_visual = (Visual *)xv_get (obj, XV_VISUAL);
        panel_x_gap = xv_get( obj, PANEL_ITEM_X_GAP );

	return obj;
}

/*
 * Create object `file_button' in the specified instance.
 */
Xv_opaque
base_window_file_button_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 10,
		PANEL_LABEL_STRING, LGET ("File"),
		PANEL_ITEM_MENU, ip->file_menu, 
		XV_HELP_DATA, "imagetool:File",
		NULL);
	return obj;
}

/*
 * Create object `edit_button' in the specified instance.
 */
Xv_opaque
base_window_edit_button_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, xv_get (ip->view_button, XV_X) +
		      xv_get (ip->view_button, XV_WIDTH) + 10,
		PANEL_LABEL_STRING, LGET ("Edit"),
		PANEL_ITEM_MENU, ip->edit_menu,
		XV_HELP_DATA, "imagetool:Edit",
		NULL);
	return obj;
}

/*
 * Create object `view_button' in the specified instance.
 */
Xv_opaque
base_window_view_button_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, xv_get (ip->file_button, XV_X) +
		      xv_get (ip->file_button, XV_WIDTH) + 10,
		PANEL_LABEL_STRING, LGET ("View"),
		PANEL_ITEM_MENU, ip->view_menu,
		XV_HELP_DATA, "imagetool:View",
		NULL);
	return obj;
}

/*
 * Create object `help_button' in the specified instance.
 */
Xv_opaque
base_window_help_button_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
        extern void     help_callback();
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, xv_get (ip->edit_button, XV_X) +
		      xv_get (ip->edit_button, XV_WIDTH) + 30,
		      /*xv_get (ip->edit_button, XV_WIDTH) / 2, */
		PANEL_LABEL_STRING, LGET ("Help..."),
		PANEL_NOTIFY_PROC, help_callback,
		XV_HELP_DATA, "imagetool:Help",
		NULL);
	return obj;
}

/*
 * Create object `page_backward_button' in the specified instance.
 */
Xv_opaque
base_window_page_backward_button_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
        extern void     prev_page ();
	Xv_opaque	obj;
	Xv_opaque	prev_image;
	static unsigned short prev_image_bits[] = {
#include "prev_page.icon"
	};

	prev_image = xv_create (XV_NULL, SERVER_IMAGE,
		SERVER_IMAGE_DEPTH, 1,
		SERVER_IMAGE_BITS, prev_image_bits,
		XV_WIDTH, 16,
		XV_HEIGHT, 16,
		NULL);
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, xv_get (ip->help_button, XV_X) +
		      xv_get (ip->help_button, XV_WIDTH) + 30,
		PANEL_LABEL_IMAGE, prev_image,
		PANEL_NOTIFY_PROC, prev_page,
		PANEL_INACTIVE, TRUE,
		XV_HELP_DATA, "imagetool:Up",
		NULL);
	return obj;
}

/*
 * Create object `page_forward_button' in the specified instance.
 */
Xv_opaque
base_window_page_forward_button_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
        extern void     next_page ();
	Xv_opaque	obj;
	Xv_opaque	next_image;
	static unsigned short next_image_bits[] = {
#include "next_page.icon"
	};

	next_image = xv_create (XV_NULL, SERVER_IMAGE,
		SERVER_IMAGE_DEPTH, 1,
		SERVER_IMAGE_BITS, next_image_bits,
		XV_WIDTH, 16,
		XV_HEIGHT, 16,
		NULL);
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, xv_get (ip->page_backward_button, XV_X) +
		      xv_get (ip->page_backward_button, XV_WIDTH) + 10, 
		PANEL_LABEL_IMAGE, next_image,
		PANEL_NOTIFY_PROC, next_page,
		PANEL_INACTIVE, TRUE,
		XV_HELP_DATA, "imagetool:Down",
		NULL);
	return obj;
}

/*
 * Create object `dragdrop' in the specified instance.
 */
Xv_opaque
base_window_dragdrop_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	Xv_opaque	source_drag_ptr_image;
	Xv_opaque	source_drop_ptr_image;
	static unsigned short source_drag_image [] = {
#include "dupedoc_drag.icon"
	};
	static unsigned short source_drop_image [] = {
#include "dupedoc_drop.icon"
	};
	extern void	ImagetoolConvertProc ();

	source_drag_ptr_image = (Server_image) xv_create (NULL, SERVER_IMAGE,
                                 XV_WIDTH, 64,
                                 XV_HEIGHT, 64,
                                 SERVER_IMAGE_BITS, source_drag_image,
                                 SERVER_IMAGE_DEPTH, 1,
                                 NULL);

	source_drop_ptr_image = (Server_image) xv_create (NULL, SERVER_IMAGE,
                                 XV_WIDTH, 64,
                                 XV_HEIGHT, 64,
                                 SERVER_IMAGE_BITS, source_drop_image,
                                 SERVER_IMAGE_DEPTH, 1,
                                 NULL);

        obj = xv_create(owner, DRAGDROP,
                             SEL_CONVERT_PROC, ImagetoolConvertProc,
                             DND_TYPE, DND_COPY,
                             DND_CURSOR, xv_create(NULL, CURSOR,
                                            CURSOR_IMAGE, source_drag_ptr_image,                                            CURSOR_XHOT, 17,
                                            CURSOR_YHOT, 24,
                                            CURSOR_OP, PIX_SRC^PIX_DST,
                                            0),
                             DND_ACCEPT_CURSOR, xv_create(NULL, CURSOR,
                                            CURSOR_IMAGE, source_drop_ptr_image,                                            CURSOR_XHOT, 17,
                                            CURSOR_YHOT, 24,
                                            CURSOR_OP, PIX_SRC^PIX_DST,
                                            0),
                             0);
	return obj;
}


/*
 * Create object `drop_target' in the specified instance.
 */
Xv_opaque
base_window_drop_target_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	extern void	drop_target_notify_proc ();
	
	obj = xv_create(owner, PANEL_DROP_TARGET,
	   	XV_KEY_DATA, INSTANCE, ip,
	   	XV_X, xv_get (ip->page_forward_button, XV_X) +
		      xv_get (ip->page_forward_button, XV_WIDTH) + 30,
		PANEL_DROP_DND, ip->dragdrop,
		PANEL_DROP_DND_TYPE, PANEL_DROP_COPY_ONLY,
		PANEL_NOTIFY_PROC, drop_target_notify_proc,
        	XV_HELP_DATA, "imagetool:DropTarget",
		NULL);

	return obj;

}

void
create_stipple_pixmap (disp)
DisplayInfo	*disp;
{
    int			tile_width = 16;
    int			tile_height = 16;
    unsigned char	tile_bits [] = {
   				0x01, 0x01, 0x00, 0x00, 
				0x80, 0x80, 0x00, 0x00, 
				0x08, 0x08, 0x00, 0x00,
   				0x00, 0x00, 0x00, 0x00, 
				0x01, 0x01, 0x00, 0x00, 
				0x80, 0x80, 0x00, 0x00,
   				0x08, 0x08, 0x00, 0x00, 
				0x00, 0x00, 0x00, 0x00};

    stipple_pixmap = XCreateBitmapFromData (disp->xdisplay, disp->win, 
					    (char *) tile_bits, tile_width, 
					    tile_height);
}

/*
 * Return the canvas depth base on either
 * command line arg or properties setting.
 */
int
canvas_depth_value ()
{
    int   depth = 8;

    if (xview_info->depth_set) 
      depth = xview_info->depth;
    else {
      char *color_value = NULL;
      extern char *int_to_color();

      color_value = strdup (int_to_color (current_props->color));
      if (strcmp (color_value, COLORS_BW) == 0)
	depth = 1;
      else if (strcmp (color_value, COLORS_16) == 0)
	depth = 4;
      else if (strcmp (color_value, COLORS_256) == 0)
	depth = 8;
      else if (strcmp (color_value, COLORS_THOUSANDS) == 0)
	depth = 16;
      else if (strcmp (color_value, COLORS_MILLIONS) == 0)
	depth = 24;

      if (color_value)
	free (color_value);
    }
    return (depth);
}

/*
 * Determine the canvas visual class based on
 * the depth of the canvas.
 */
int
canvas_visual_class (depth)
{
    int          vis_class;
    int          color_set = FALSE;
    char        *view_value = NULL;
    extern char *int_to_view();
    extern int   gray_vis1;
    extern int   color_vis1;
    extern int   gray_vis4;
    extern int   color_vis4;
    extern int   gray_vis8;
    extern int   color_vis8;
    extern int   gray_vis16;
    extern int   color_vis16;
    extern int   gray_vis24;
    extern int   color_vis24;

    view_value = strdup (int_to_view (current_props->view_in));

    if (strcmp (view_value, VIEW_COLOR) == 0)
      color_set = TRUE;

    if (depth == 1) {
      if (color_set && color_vis1 != -1)    
        vis_class = color_vis1;
      else if (gray_vis1 != -1)
	vis_class = gray_vis1;
    }
    else if (depth == 4) {
      if (color_set && color_vis4 != -1)
        vis_class = color_vis4;
      else if (gray_vis4 != -1)
	vis_class = gray_vis4;
    }
    else if (depth == 8) {
      if (color_set && color_vis8 != -1)
        vis_class = color_vis8;
      else if (gray_vis8 != -1)
	vis_class = gray_vis8;
    }
    else if (depth == 16) {
      if (color_set && color_vis16 != -1)
        vis_class = color_vis16;
      else if (gray_vis16 != -1)
	vis_class = gray_vis16;
    }
    else if (depth == 24) {
      if (color_set && color_vis24 != -1)
        vis_class = color_vis24;
      else if (gray_vis24 != -1)
	vis_class = gray_vis24;
    }

    return (vis_class);

}

/*
 * Determine the canvas visual class based on
 * the depth of the canvas.
 */
static int
ps_canvas_visual_class (depth)
{
    int          vis_class;
    int          color_set = FALSE;
    char        *view_value = NULL;
    extern char *int_to_view();
    extern int   gray_vis1;
    extern int   color_vis1;
    extern int   gray_vis4;
    extern int   color_vis4;
    extern int   gray_vis8;
    extern int   color_vis8;
    extern int   gray_vis16;
    extern int   color_vis16;
    extern int   gray_vis24;
    extern int   color_vis24;

    view_value = strdup (int_to_view (current_props->view_in));

    if (strcmp (view_value, VIEW_COLOR) == 0)
      color_set = TRUE;

    if (depth == 1) {
      if (color_set && color_vis1 != -1)    
        vis_class = color_vis1;
      else if (gray_vis1 != -1)
	vis_class = gray_vis1;
    }
    else if (depth == 4) {
      if (color_set && color_vis4 != -1)
        vis_class = StaticColor;
      else if (gray_vis4 != -1)
	vis_class = StaticGray;
    }
/*
 * Special case.
 * Warning: may cause problems later if these
 * visual are not supported in 8-bit, but necessary for postscript..
 */
    else if (depth == 8) {
      if (color_set && color_vis8 != -1)
	vis_class = StaticColor;
      else if (gray_vis8 != -1)
	vis_class = StaticGray;
    }
    else if (depth == 16) {
      if (color_set && color_vis16 != -1)
        vis_class = color_vis16;
      else if (gray_vis16 != -1)
	vis_class = gray_vis16;
    }
    else if (depth == 24) {
      if (color_set && color_vis24 != -1)
        vis_class = color_vis24;
      else if (gray_vis24 != -1)
	vis_class = gray_vis24;
    }

    return (vis_class);

}

/*
 * Create object `canvas' in the specified instance.
 */
Xv_opaque
base_window_canvas_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	Colormap	cmap;
	XColor		ccolor;
	unsigned long   gc_mask;
 	XGCValues 	gc_vals;
	Window		**wins;
	Window		*new_wins;
	int		count = 0;
	int		i;
	int		vis_class, depth;
        int             width, widthmm, height, heightmm;
	extern void	repaint_image ();
	extern void	canvas_event_proc ();
        extern Xil_boolean xil_error_handler ();

        depth     = canvas_depth_value();
        vis_class = canvas_visual_class (depth);

	obj = xv_create(owner, CANVAS,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, (int)xv_get(ip->base_panel, XV_Y) +
		      (int)xv_get(ip->base_panel, XV_HEIGHT),
		XV_WIDTH, WIN_EXTEND_TO_EDGE,
		XV_HEIGHT, WIN_EXTEND_TO_EDGE,
		XV_DEPTH, depth,
		XV_VISUAL_CLASS, vis_class,
	        CANVAS_X_PAINT_WINDOW, TRUE,
                CANVAS_REPAINT_PROC, repaint_image,
                CANVAS_RETAINED, FALSE,
		CANVAS_AUTO_EXPAND, FALSE,
		CANVAS_AUTO_SHRINK, FALSE,
                CANVAS_PAINTWINDOW_ATTRS,
                           WIN_TRANSPARENT,
                           WIN_EVENT_PROC, canvas_event_proc,
			   NULL,
        	XV_HELP_DATA, "imagetool:Canvas",
		OPENWIN_SHOW_BORDERS, TRUE,
		WIN_BACK,
		NULL);
	/*
	 * This line is here for backwards compatibility. It will be
	 * removed for the next release.
	 */
	xv_set (canvas_paint_window(obj), XV_KEY_DATA, INSTANCE, ip,
                WIN_IGNORE_X_EVENT_MASK,
                 ButtonReleaseMask | ButtonPressMask | Button1MotionMask,
		NULL);

	image_display->state = xil_open();
	if (image_display->state == NULL) {
	  fprintf (stderr, MGET ("%s: Unable to open XIL Library.\n"), prog->name);
	  exit (1);
        }
#ifdef DEBUG
	xil_state_set_synchronize (image_display->state, ON);
#endif
        xil_install_error_handler (image_display->state, xil_error_handler);
	image_display->visual = (Visual *) xv_get (obj, XV_VISUAL);
	image_display->depth = xv_get (obj, XV_DEPTH);

	image_display->canvas = obj;
	image_display->paint_win = canvas_paint_window (obj);
	image_display->win = xv_get (image_display->paint_win, XV_XID);
	image_display->display_win = 
		xil_create_from_window (image_display->state,
					image_display->xdisplay,
					image_display->win);

	image_display->pixmap1 = NULL;
	image_display->pixmap2 = NULL;

/*
 * Note, this should work... ie. figuring out the x and y screen
 * resolutions. But it doesn't!  So, we default to 83 which seems
 * be correct for most of the large monitors.
 */

#ifdef LATER
        width = (float) DisplayWidth (image_display->xdisplay, 
				      DefaultScreen (image_display->xdisplay));
        widthmm = (float) DisplayWidthMM (image_display->xdisplay,
					  DefaultScreen (image_display->xdisplay));
        height = (float) DisplayHeight (image_display->xdisplay, 
					DefaultScreen (image_display->xdisplay));
        heightmm = (float) DisplayHeightMM (image_display->xdisplay,
					    DefaultScreen (image_display->xdisplay));
        image_display->res_x = width / (widthmm / 25.4);
        image_display->res_y = height / (heightmm / 25.4);
#endif

        image_display->res_x = 83.0;
        image_display->res_y = 83.0;


/*
 * First get the colormap...
 */
 
	cmap = (Colormap) xv_get (xv_get (obj, WIN_CMS), CMS_CMAP_ID);
 
/*
 * Next, get the pixel index for White
 */
 
	ccolor.red = ccolor.blue = ccolor.green = 65535;
	XAllocColor (image_display->xdisplay, cmap, &ccolor);
	gc_vals.background = ccolor.pixel;
 
/*
 * Next, get the pixel index for Black
 */
 
	ccolor.red = ccolor.blue = ccolor.green = 0;
	XAllocColor (image_display->xdisplay, cmap, &ccolor);
	gc_vals.foreground = ccolor.pixel;
 
	gc_mask = GCForeground | GCBackground;
 
        image_display->win_gc = XCreateGC (image_display->xdisplay, 
					   image_display->win, gc_mask, 
					   &gc_vals);

	ccolor.red = ccolor.blue = ccolor.green = (230 << 8) + 230;
	XAllocColor (image_display->xdisplay, cmap, &ccolor);
	gc_vals.background = ccolor.pixel;

	if (stipple_pixmap == NULL)
	   create_stipple_pixmap (image_display);

	gc_vals.stipple = stipple_pixmap;
	gc_vals.fill_style = FillOpaqueStippled;

	gc_mask = GCForeground | GCBackground | GCFillStyle | GCStipple;
 
        if (image_display->depth == 24)
  	  image_display->background[0] = image_display->background[1] =
	    image_display->background[2] = 230;
        else
  	  image_display->background[0] = ccolor.pixel; 

	image_display->fill_gc = XCreateGC (image_display->xdisplay, 
					    image_display->win, gc_mask, 
					    &gc_vals);

/*
 * create the select gc too.
 */

        ccolor.red = ccolor.blue = ccolor.green = 40000;
    	XAllocColor( image_display->xdisplay, cmap, &ccolor );
    	gc_vals.background = ccolor.pixel;
 
    	ccolor.red = ccolor.blue = ccolor.green = 0;
    	XAllocColor( image_display->xdisplay, cmap, &ccolor );
    	gc_vals.foreground = ccolor.pixel;

    	gc_vals.function = GXxor;          
        gc_vals.line_width = 2;
        gc_vals.line_style = LineDoubleDash;
    	gc_mask = GCForeground | GCBackground | GCFunction | 
		  GCLineWidth | GCLineStyle;
    	image_display->select_gc = XCreateGC (image_display->xdisplay, 
					      image_display->win, 
					      gc_mask, &gc_vals );

/*
 * Intall colormap property on the canvas paint window.
 * if olwm then... Fix later.
 */                          
	wins = (Window **) malloc (sizeof (Window *));
	XGetWMColormapWindows (image_display->xdisplay, 
			       xv_get(ip->base_window, XV_XID),
			       wins, &count);

	new_wins = (Window *) malloc (sizeof (Window) * (count + 1));
	for (i = 0; i < count; i++)
	    new_wins [i] = wins [0][i];

	new_wins [count++] = image_display->win;
/*
        XSetWMColormapWindows (image_display->xdisplay, 
			       xv_get(ip->base_window, XV_XID),
			       new_wins, count);
*/

	image_display->height = xv_get (obj, CANVAS_HEIGHT);
	image_display->width = xv_get (obj, CANVAS_WIDTH);
	free (new_wins);
	free (wins);
	return obj;
}

/*
 * Create object `hscroll' in the specified instance.
 */
Xv_opaque
base_window_hscroll_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;

	obj = xv_create(owner, SCROLLBAR,
		SCROLLBAR_DIRECTION,	SCROLLBAR_HORIZONTAL,
		XV_VISUAL,		panel_visual,
		WIN_CMS,		panel_cms,
		NULL);
 
	scroll_height = xv_get (obj, XV_HEIGHT);
	return (obj);
}

/*
 * Create object `vscroll' in the specified instance.
 */
Xv_opaque
base_window_vscroll_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
 
	obj = xv_create(owner, SCROLLBAR,
		SCROLLBAR_DIRECTION,	SCROLLBAR_VERTICAL,
		XV_VISUAL,		panel_visual,
		WIN_CMS,		panel_cms,
		NULL);
 
	scroll_width = xv_get (obj, XV_WIDTH);
	return (obj);
}

/*
 * Create object `ps_canvas' in the specified instance.
 */
Xv_opaque
base_window_ps_canvas_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	  obj;
	int		  vis_class, depth;
	Colormap	  cmap;
	XColor		  ccolor;
	XGCValues	  gc_vals;
	Display		 *xdisplay;
	unsigned long	  gc_mask;
	Window		**wins;
	Window		 *new_wins;
	int		  count = 0;
	int		  i;
	int		  major_opcode, first_event, first_error;
        int               width, widthmm, height, heightmm;
	Visual		 *def_visual;
	int		  def_screen, def_depth, def_vis;
	extern void	  repaint_image ();
	extern void	  canvas_event_proc ();
	extern int	  display_postscript_present();
	
	xdisplay = (Display *) xv_get (owner, XV_DISPLAY);
        depth = canvas_depth_value ();
      
/*
 * Determine if we're running on a dps based server.
 */

	
/*
	prog->dps = XQueryExtension (xdisplay, DPS_EXTENSION, &major_opcode, 
				     &first_event, &first_error);
*/
	prog->dps = display_postscript_present(xdisplay);
                         
	if (prog->dps == TRUE) {
	   def_screen = DefaultScreen (xdisplay);
	   def_depth = xv_get (owner, XV_DEPTH);
	   def_vis = xv_get (owner, XV_VISUAL_CLASS);

/*
 * vis_class returns PseudoColor, GrayScale (depth 4, 8 or 16), 
 * TrueColor (depth 24) or StaticGray (depth 1).
 */ 

           vis_class = canvas_visual_class (depth); 


/*
 * Ok, now check and see if we can reduce flashing by making the
 * canvas from a `better' visual.
 */

	   if ((def_depth != 1) && (depth == def_depth)) {
	      if ((vis_class == GrayScale) && (def_vis == StaticGray)) 
		 vis_class = StaticGray;
	      else if ((vis_class == PseudoColor) && (def_vis == StaticColor)) 
		 vis_class = StaticColor;
/*
	      else if ((vis_class == TrueColor) && (def_vis == DirectColor) &&
		       (depth != 8)) 
		 vis_class = DirectColor;
*/
	      }
	   }
	else
           vis_class = ps_canvas_visual_class (depth); 

	obj = xv_create(owner, CANVAS,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, (int)xv_get(ip->base_panel, XV_Y) +
		      (int)xv_get(ip->base_panel, XV_HEIGHT),
		XV_WIDTH, WIN_EXTEND_TO_EDGE,
		XV_HEIGHT, WIN_EXTEND_TO_EDGE,
	        CANVAS_X_PAINT_WINDOW, TRUE,
                CANVAS_REPAINT_PROC, repaint_image,
                CANVAS_RETAINED, FALSE,
		CANVAS_AUTO_EXPAND, FALSE,
		CANVAS_AUTO_SHRINK, FALSE,
		XV_DEPTH, depth,
		XV_VISUAL_CLASS, vis_class,
		CANVAS_FIXED_IMAGE, FALSE,
		OPENWIN_AUTO_CLEAR, FALSE,
		OPENWIN_SHOW_BORDERS, TRUE,
                CANVAS_PAINTWINDOW_ATTRS,
                           WIN_TRANSPARENT,
                           WIN_EVENT_PROC, canvas_event_proc,
                           WIN_CONSUME_EVENTS,
                                WIN_ASCII_EVENTS,
                                WIN_LEFT_KEYS, WIN_RIGHT_KEYS,
				WIN_CLIENT_MESSAGE,
                                NULL,
                           NULL,
                XV_HELP_DATA, "imagetool:Canvas",
		NULL);

	/*
	 * This line is here for backwards compatibility. It will be
	 * removed for the next release.
	 */

	xv_set (canvas_paint_window(obj), XV_KEY_DATA, INSTANCE, ip, 
                WIN_IGNORE_X_EVENT_MASK,
                  ButtonReleaseMask | ButtonPressMask | Button1MotionMask,
		NULL);

	if (prog->dps == TRUE)
	   make_std_colormaps (obj, vis_class);

	ps_display->xdisplay = xdisplay;
	ps_display->depth = xv_get (obj, XV_DEPTH);
	ps_display->visual = (Visual *) xv_get (obj, XV_VISUAL);

	ps_display->canvas = obj;
	ps_display->paint_win = canvas_paint_window (obj);
	ps_display->win = (Window) xv_get (ps_display->paint_win, XV_XID);

	ps_display->pixmap1 = NULL;
	ps_display->pixmap2 = NULL;

/*
 * Note, this should work... ie. figuring out the x and y screen
 * resolutions. But it doesn't!  So, we default to 83 which seems
 * be correct for most of the large monitors.
 */

#ifdef LATER
        width = (float) DisplayWidth (image_display->xdisplay, 
				      DefaultScreen (image_display->xdisplay));
        widthmm = (float) DisplayWidthMM (image_display->xdisplay,
					  DefaultScreen (image_display->xdisplay));
        height = (float) DisplayHeight (image_display->xdisplay, 
					DefaultScreen (image_display->xdisplay));
        heightmm = (float) DisplayHeightMM (image_display->xdisplay,
					    DefaultScreen (image_display->xdisplay));
        ps_display->res_x = width / (widthmm / 25.4);
        ps_display->res_y = height / (heightmm / 25.4);
#endif

        ps_display->res_x = 83.0;
        ps_display->res_y = 83.0;

/*
 * First get the colormap...
 */
 
	cmap = (Colormap) xv_get (xv_get (obj, WIN_CMS), CMS_CMAP_ID);
 
/*
 * Next, get the pixel index for White
 */
 
	ccolor.red = ccolor.blue = ccolor.green = 65535;
	XAllocColor (ps_display->xdisplay, cmap, &ccolor);
	gc_vals.background = ccolor.pixel;
 
/*
 * Next, get the pixel index for Black
 */
 
	ccolor.red = ccolor.blue = ccolor.green = 0;
	XAllocColor (ps_display->xdisplay, cmap, &ccolor);
	gc_vals.foreground = ccolor.pixel;
 
	gc_mask = GCForeground | GCBackground;
	ps_display->win_gc = XCreateGC (ps_display->xdisplay, 
					ps_display->win, gc_mask, &gc_vals);

	ccolor.red = ccolor.blue = ccolor.green = (230 << 8) + 230;
	XAllocColor (ps_display->xdisplay, cmap, &ccolor);
	gc_vals.background = ccolor.pixel;

	if (stipple_pixmap == NULL)
	   create_stipple_pixmap (ps_display);

	gc_vals.stipple = stipple_pixmap;
	gc_vals.fill_style = FillOpaqueStippled;

	gc_mask = GCForeground | GCBackground | GCFillStyle | GCStipple;
 
	ps_display->fill_gc = XCreateGC (ps_display->xdisplay, 
					 ps_display->win, gc_mask, &gc_vals);

/*
 * create the select gc too.
 */

        ccolor.red = ccolor.blue = ccolor.green = 40000;
    	XAllocColor( ps_display->xdisplay, cmap, &ccolor );
    	gc_vals.background = ccolor.pixel;
 
    	ccolor.red = ccolor.blue = ccolor.green = 0;
    	XAllocColor( ps_display->xdisplay, cmap, &ccolor );
    	gc_vals.foreground = ccolor.pixel;

    	gc_vals.function = GXxor;          
        gc_vals.line_width = 2;
	gc_vals.line_style = LineDoubleDash;
    	gc_mask = GCForeground | GCBackground | GCFunction |
		  GCLineWidth | GCLineStyle;
    	ps_display->select_gc = XCreateGC (ps_display->xdisplay, 
					   ps_display->win, gc_mask, &gc_vals );

	xv_set (obj, WIN_BACK, NULL);

/*
 * Intall colormap property on the canvas paint window.
 * if olwm then... Fix later.
 */                          
	wins = (Window **) malloc (sizeof (Window *));
	XGetWMColormapWindows (ps_display->xdisplay, 
			       xv_get(ip->base_window, XV_XID),
			       wins, &count);

	new_wins = (Window *) malloc (sizeof (Window) * (count + 1));
	for (i = 0; i < count; i++)
	    new_wins [i] = wins [0][i];

	new_wins [count++] = ps_display->win;
/*
        XSetWMColormapWindows (ps_display->xdisplay, 
			       xv_get(ip->base_window, XV_XID),
			       new_wins, count);
*/

/*
 * These should be retrieved from property data..
 */

	ps_display->width = xv_get (obj, CANVAS_WIDTH);
	ps_display->height = xv_get (obj, CANVAS_HEIGHT);
	ps_display->pageheight = 11.0;
	ps_display->pagewidth = 8.5;

/*
 * Calculate the default ps scale.
 */
        ps_default_scale ();

	return obj;
}

/*
 * Create object `ps_hscroll' in the specified instance.
 */
Xv_opaque
base_window_ps_hscroll_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;

	obj = xv_create(owner, SCROLLBAR,
		SCROLLBAR_DIRECTION,	SCROLLBAR_HORIZONTAL,
		XV_VISUAL,		panel_visual,
		WIN_CMS,		panel_cms,
		NULL);
 
	scroll_height = xv_get (obj, XV_HEIGHT);
	return (obj);
}

/*
 * Create object `ps_vscroll' in the specified instance.
 */
Xv_opaque
base_window_ps_vscroll_create(ip, owner)
	BaseWindowObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
 
	obj = xv_create(owner, SCROLLBAR,
		SCROLLBAR_DIRECTION,	SCROLLBAR_VERTICAL,
		XV_VISUAL,		panel_visual,
		WIN_CMS,		panel_cms,
		NULL);
 
	scroll_width = xv_get (obj, XV_WIDTH);
	return (obj);
}

