
#ifndef lint
static char sccsid[] = "@(#)ps_optionsui.c 1.18 93/05/25";
#endif

/*
 * Copyright (c) 1986, 1987, 1988 by Sun Microsystems, Inc.
 */

/*
 * ps_optionsui.c - User interface object initialization functions
 * for image info pop up.
 * This file was generated by `gxv' from `imagetool.G'.
 */

#include <xview/xview.h>
#include <xview/panel.h>
#include "display.h"
#include "image.h"
#include "imagetool.h"
#include "state.h"
#include "ui_imagetool.h"

extern  int scroll_height;
extern  int pages_rendered;

float	page_widths [6] = { 8.5, 8.5, 11.0, 11.6875, 8.25, 6.929 };
float	page_heights [6] = { 11.0, 14.0, 17.0, 16.5625, 11.75, 9.843 };

/*
 * Initialize an instance of object `attributes'.
 */
PsOptionsObjects *
PsOptionsObjectsInitialize(ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	int	longest_width;
	int	label_width;
	int	items_width;
	int	orientation_label_width;
	int	order_label_width;
	int	size_label_width;
	int	orientation_width;
	int	order_width;
	int	size_width;
	int	buttons_width;
	int	margin = 25;
	
	if (!ip && 
	    !(ip = (PsOptionsObjects *) calloc(1, sizeof (PsOptionsObjects))))
		return (PsOptionsObjects *) NULL;
	if (!ip->ps_options)
		ip->ps_options = ps_options_ps_options_create(ip, owner);
	if (!ip->controls)
		ip->controls = ps_options_controls_create(ip, ip->ps_options);

	if (!ip->orientation)
		ip->orientation = ps_options_orientation_create (ip, 
							ip->controls); 
 	orientation_label_width = xv_get (ip->orientation, PANEL_LABEL_WIDTH);

	if (!ip->order)
		ip->order = ps_options_order_create(ip, ip->controls); 
 	order_label_width = xv_get (ip->order, PANEL_LABEL_WIDTH);

	label_width = Max (orientation_label_width, order_label_width);

	if (!ip->size)
		ip->size = ps_options_size_create(ip, ip->controls);
 	size_label_width = xv_get (ip->size, PANEL_LABEL_WIDTH);

	label_width = Max (label_width, size_label_width);

	orientation_width = xv_get (ip->orientation, XV_WIDTH) - 
			    orientation_label_width + label_width; 
	order_width = xv_get (ip->order, XV_WIDTH) - order_label_width +
		      label_width; 
	size_width = xv_get (ip->size, XV_WIDTH) - size_label_width + 
		     label_width;
    
	items_width = Max (orientation_width, order_width);
	items_width = Max (items_width, size_width);

	if (!ip->apply)
		ip->apply = ps_options_apply_create(ip, ip->controls);
	if (!ip->cancel)
		ip->cancel= ps_options_cancel_create(ip, ip->controls);

	buttons_width = xv_get (ip->apply, XV_WIDTH) + 
			xv_get (ip->cancel, XV_WIDTH) + margin;

	longest_width = Max (items_width, buttons_width);

	xv_set (ip->apply, XV_X, (longest_width - buttons_width) / 2 + margin, 
			   NULL);
	xv_set (ip->cancel, XV_X, xv_get (ip->apply, XV_X) +
				  xv_get (ip->apply, XV_WIDTH) + margin,
			    NULL);

	if (buttons_width > items_width) 
	   margin += (buttons_width - items_width) / 25;

	xv_set (ip->orientation, XV_X, (label_width - orientation_label_width) +
				        margin,
	      		         NULL);
	xv_set (ip->order, XV_X, (label_width - order_label_width) + margin,
	      		   NULL);
	xv_set (ip->size, XV_X, (label_width - size_label_width) + margin,
			  NULL);

	xv_set (ip->controls, XV_WIDTH, longest_width + 50,
			      XV_HEIGHT, xv_get (ip->apply, XV_Y) +
				         xv_get (ip->apply, XV_HEIGHT) + 25,
			      PANEL_DEFAULT_ITEM, ip->apply, 
			      NULL);

	xv_set (ip->ps_options, XV_WIDTH, longest_width + 50,
			        XV_HEIGHT, xv_get (ip->apply, XV_Y) +
				           xv_get (ip->apply, XV_HEIGHT) + 25,
			        NULL);
	
	return ip;
}

/*
 * Create object `ps_options' in the specified instance.
 */
Xv_opaque
ps_options_ps_options_create(ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, FRAME_CMD,
		XV_KEY_DATA, INSTANCE, ip,
		XV_LABEL, LGET( "Image Tool:  Page Viewing Controls" ),
		XV_SHOW, FALSE,
		FRAME_SHOW_FOOTER, FALSE,
		FRAME_SHOW_RESIZE_CORNER, FALSE,
		FRAME_CMD_PUSHPIN_IN, FALSE,
		NULL);
	return obj;
}

/*
 * Create object `controls' in the specified instance.
 */
Xv_opaque
ps_options_controls_create(ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	/*obj = xv_create(owner, PANEL, */
	obj = xv_get (owner, FRAME_CMD_PANEL);
	xv_set (obj,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, 0,
		WIN_BORDER, FALSE,
		XV_HELP_DATA, "imagetool:PsOptionsWindow",
		NULL);
	return obj;
}

/*
 * Create object `orientation' in the specified instance.
 */
Xv_opaque
ps_options_orientation_create (ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_CHOICE,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, 25,
		PANEL_LABEL_STRING, LGET ("Orientation:"),
		PANEL_LABEL_BOLD, TRUE,
		PANEL_CHOICE_STRINGS,
			LGET ("Portrait"),
			LGET ("Landscape"),
			NULL,
                XV_HELP_DATA, "imagetool:PsOptionsOrientation",
		NULL);

	return obj;
}

/*
 * Create object `order' in the specified instance.
 */
Xv_opaque
ps_options_order_create (ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_CHOICE,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, xv_get (ip->orientation, XV_Y) + 
		      xv_get (ip->orientation, XV_HEIGHT) + 30,
		PANEL_LABEL_STRING, LGET ("Order:"),
		PANEL_LABEL_BOLD, TRUE,
		PANEL_CHOICE_STRINGS,
			LGET ("First Page First"),
			LGET ("Last Page First"),
			NULL,
                XV_HELP_DATA, "imagetool:PsOptionsOrder",
		NULL);

 	if (current_image->pages == 1)
           xv_set (obj, PANEL_INACTIVE, TRUE, NULL);

	if (current_state->reversed == TRUE)
	   xv_set (obj, PANEL_VALUE, 1, NULL);

	return obj;
}

/*
 * Create object `size' in the specified instance.
 */
Xv_opaque
ps_options_size_create(ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	int		order_choice_width,
			sbar_width,
			orientation_choice_width,
			max_choice_width;
	
	obj = xv_create(owner, PANEL_LIST,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, xv_get (ip->order, XV_Y) + 
		      xv_get (ip->order, XV_HEIGHT) + 30,
		PANEL_LABEL_STRING, LGET ("Size:"),
		PANEL_LABEL_BOLD, TRUE,
                PANEL_LIST_DISPLAY_ROWS, 3,
                PANEL_LAYOUT, PANEL_HORIZONTAL,
                PANEL_READ_ONLY, FALSE,
                PANEL_CHOOSE_ONE, TRUE,
                PANEL_CHOOSE_NONE, FALSE,
                PANEL_LIST_STRINGS,
                        LGET ("8.5 x 11 in (Letter)"),
                        LGET ("8.5 x 14 in (Legal)"),
                        LGET ("11  x 17 in (Ledger)"),
                        LGET ("29.7 x 42 cm (A3)"),
                        LGET ("21 x 29.7 cm (A4)"),
                        LGET ("17.6 x 25 cm (B5)"),
                        NULL,
                PANEL_LIST_SELECT, 0, TRUE,
                XV_HELP_DATA, "imagetool:PsOptionsSize",
		NULL); 

/*
 * Looks like there is about a 2 pixel difference between the scrollbar
 * and the panel list.
 */

	sbar_width = xv_get (xv_get (obj, PANEL_LIST_SCROLLBAR), XV_WIDTH) - 3;

/*
 * Check to see if the choice items are longer than the list width,
 * and if so, reset the PANEL_LIST_WIDTH.
 */

	order_choice_width = xv_get (ip->order, XV_WIDTH) - 
			     (xv_get (ip->order, PANEL_VALUE_X) -
			      xv_get (ip->order, PANEL_LABEL_X));
	orientation_choice_width = xv_get (ip->orientation, XV_WIDTH) -
			           (xv_get (ip->orientation, PANEL_VALUE_X) -
			            xv_get (ip->orientation, PANEL_LABEL_X));

        max_choice_width = Max (order_choice_width, orientation_choice_width);

        if ((xv_get (obj, PANEL_LIST_WIDTH) + sbar_width) < max_choice_width) 
	   xv_set (obj, PANEL_LIST_WIDTH, max_choice_width - sbar_width, NULL);

	return obj; 
} 

/*
 * Create object `apply' in the specified instance.
 */
Xv_opaque
ps_options_apply_create(ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	extern void	ps_apply_notify_proc ();
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, xv_get (ip->size, XV_Y) +
		      xv_get (ip->size, XV_HEIGHT) + 40,
		PANEL_LABEL_STRING, LGET ("Apply"),
		PANEL_NOTIFY_PROC, ps_apply_notify_proc,
                XV_HELP_DATA, "imagetool:PsOptionsApply",
		NULL);
	return obj;
}

/*
 * Create object `cancel' in the specified instance.
 */
Xv_opaque
ps_options_cancel_create(ip, owner)
	PsOptionsObjects	*ip;
	Xv_opaque	owner;
{
	Xv_opaque	obj;
	extern void	ps_cancel_notify_proc ();
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, xv_get (ip->apply, XV_WIDTH) + 40,
		XV_Y, xv_get (ip->apply, XV_Y ),
		PANEL_LABEL_STRING, LGET ("Cancel"),
		PANEL_NOTIFY_PROC, ps_cancel_notify_proc,
                XV_HELP_DATA, "imagetool:PsOptionsCancel",
		NULL);
	return obj;
}

void
ps_default_scale ()
{
   int display_height = DisplayHeight (ps_display->xdisplay,
				       DefaultScreen (ps_display->xdisplay));
   int view_height, pix_height;

   view_height = display_height - xv_get (base_window->base_panel, XV_HEIGHT) -
		 scroll_height - 2;
   pix_height = ps_display->pageheight * (int) ps_display->res_y;

/*
 * Change scale only if we can make it larger than 100%.
 */
   if (view_height > pix_height) {
      prog->def_ps_zoom = (int) (((float) view_height / (float) pix_height) * 100);
      if ((current_state != NULL) && (current_state->zoom == 1.0))
       current_state->zoom = (float) prog->def_ps_zoom / 100.0;
   }
   else 
      prog->def_ps_zoom = 100;

}

void
ps_apply_notify_proc (item, event)
Panel_item	 item;
Event		*event;
{
    int		row;
    int		old_angle = current_state->angle;
    int 	old_reversed = current_state->reversed;
    float 	old_width = ps_display->pagewidth;
    float	old_height = ps_display->pageheight;
    float	old_zoom;

    setbusy ();
    
    current_state->reversed = FALSE;
    if (xv_get (ps_options->order, PANEL_VALUE) == 1)
       current_state->reversed = TRUE;

    if (xv_get (ps_options->orientation, PANEL_VALUE) == PORTRAIT)
       current_state->angle = 0;
    else
       current_state->angle = 90;

    row = current_list_selection (ps_options->size);
    ps_display->pageheight = page_heights [row];
    ps_display->pagewidth = page_widths [row];
  
    old_zoom = current_state->zoom;
    ps_default_scale ();
    if ((old_zoom != current_state->zoom) && (palette != NULL)) {
       xv_set (palette->zoom_value,  
			PANEL_VALUE, (int) (current_state->zoom * 100.0) , 
			NULL);
       xv_set (palette->zoom_slider,  
			PANEL_VALUE, (int) (current_state->zoom * 100.0),
			NULL);
       }

    if ((old_width != ps_display->pagewidth) ||
	(old_height != ps_display->pageheight) ||
	(old_angle != current_state->angle)) {
       reset_ps (((old_width != ps_display->pagewidth) ||
		  (old_height != ps_display->pageheight)),
		 ((old_angle != current_state->angle) ||
		  (old_width != ps_display->pagewidth) ||
		  (old_height != ps_display->pageheight))) ;
       if (old_reversed != current_state->reversed)
	  if ((pageview != NULL) && (pages_rendered == TRUE))
             reverse_pageview_pages (pageview, current_image->pages,
	     			     current_state->reversed);
       }
    else {
       if (old_reversed != current_state->reversed) {

	  goto_page (current_state->current_page, TRUE, FALSE);
	  if ((pageview != NULL) && (pages_rendered == TRUE))
             reverse_pageview_pages (pageview, current_image->pages,
				     current_state->reversed);
	  }
       }

/*
 * If we changed the angle, and undo is on, and the undo op is
 * a rotation, we should figure out how to get it back to where 
 * it was.
 */

    if ((old_angle != current_state->angle) &&
        (((current_state->undo).op == ROTATE_L) ||
         ((current_state->undo).op == ROTATE_R))) {

/*
 * If we are now LANDSCAPE, and old angle was 0-89 or 270-359, then
 *    we did a rotate right. If the angle was 91-269 then we did a 
 *    rotate left.
 */

       if (current_state->angle == 90) {
	  if ((old_angle >= 91) && (old_angle <= 269)) {
	     (current_state->undo).op = ROTATE_R;
	     current_state->rotate_amt = old_angle - current_state->angle;
	     }
	  else {
	     (current_state->undo).op = ROTATE_L;
	     if ((old_angle >= 0) && (old_angle <= 89))
	        current_state->rotate_amt = current_state->angle - old_angle;
	     else
	        current_state->rotate_amt = current_state->angle +
					    (360 - old_angle);
	     }
	  }

/*
 * If we are now PORTRAIT, and old angle was 1-180, then we did a
 *    rotate left. If the angle was 181-359, then we did a rotate
 *    right.
 */

       else {
	  if ((old_angle >= 1) && (old_angle <= 180)) {
	     (current_state->undo).op = ROTATE_R;
	     current_state->rotate_amt = old_angle; 
	     }
	  else {
	     (current_state->undo).op = ROTATE_L;
	     current_state->rotate_amt = 360 - old_angle;
	     }
	  }
       }
      
    setactive ();
}

void
ps_cancel_notify_proc (item, event)
Panel_item	 item;
Event		*event;
{

    xv_set (ps_options->ps_options, FRAME_CMD_PUSHPIN_IN, FALSE,	
				    XV_SHOW,		  FALSE,
				    NULL);
}
