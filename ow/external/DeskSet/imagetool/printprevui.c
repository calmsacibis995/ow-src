
#ifndef lint
static char sccsid[] = "@(#)printprevui.c 1.17 94/01/10";
#endif

/*
 * Copyright (c) 1986, 1987, 1988 by Sun Microsystems, Inc.
 */

/*
 * printprevui.c - User interface object initialization functions
 * for print preview pop up.
 * This file was generated by `gxv' from `imagetool.G'.
 */

#include <sys/param.h>
#include <xview/xview.h>
#include <xview/canvas.h>
#include <xview/cursor.h>
#include <xview/panel.h>
#include "display.h"
#include "imagetool.h" 
#include "ui_imagetool.h"
#include "ds_popup.h"

/*
 * Initialize an instance of object `print_prev'.
 */
PrintPreviewObjects *
PrintPreviewObjectsInitialize (ip, owner)
	PrintPreviewObjects	*ip;
	Xv_opaque		 owner;
{
	if (!ip && !(ip = (PrintPreviewObjects*) calloc (1, 
					sizeof (PrintPreviewObjects))))
		return (PrintPreviewObjects *) NULL;
	if (!ip->print_prev)
		ip->print_prev = print_prev_print_prev_create(ip, owner);
	if (!ip->page)
		ip->page = print_prev_page_create (ip, ip->print_prev);
	if (!ip->controls)
		ip->controls = print_prev_controls_create (ip, ip->print_prev);
	if (!ip->print)
		ip->print = print_prev_print_create (ip, ip->controls);
	if (!ip->cancel)
		ip->cancel = print_prev_cancel_create (ip, ip->controls);
	xv_set (ip->controls, PANEL_DEFAULT_ITEM, ip->print, NULL);
	return ip;
}

/*
 * Create object `print_prev' in the specified instance.
 */
Xv_opaque
print_prev_print_prev_create (ip, owner)
	PrintPreviewObjects	*ip;
	Xv_opaque		 owner;
{
	Xv_opaque	obj;
  
	obj = xv_create(owner, FRAME_CMD,
		XV_KEY_DATA, INSTANCE, ip,
		XV_LABEL, LGET ("Image Tool:  Print Preview"),
		FRAME_SHOW_FOOTER, FALSE,
		FRAME_SHOW_RESIZE_CORNER, FALSE,
		FRAME_CMD_PUSHPIN_IN, FALSE,
		NULL);

	return obj;
}

/*
 * Create object `page' in the specified instance.
 */
Xv_opaque
print_prev_page_create (ip, owner)
	PrintPreviewObjects	*ip;
	Xv_opaque		 owner;
{
	Xv_opaque	  obj;
        Window            win;      
	Window		**wins;
	int		  i;
	int		  count = 0;
        int               vis_class, depth;
	Window		 *new_wins;
	extern void	  repaint_print_preview ();
	extern void	  print_preview_pan (); 
        extern int        canvas_depth_value ();
        extern int        canvas_visual_classs();
	
/*
 * Make this canvas, same depth/visual as the view one, so that
 * the XIL image is already in the right conf.
 * Actually, can use the same colormap also.
 */
        depth = canvas_depth_value ();
        vis_class = canvas_visual_class (depth);

	if (!cursor)
	   cursor = CursorObjectsInitialize (NULL,
                                             base_window->base_window);

	obj = xv_create(owner, CANVAS,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, 0,
		XV_WIDTH, WIN_EXTEND_TO_EDGE,
		XV_HEIGHT, PRINT_PREVIEW_PAGE_FACTOR * 11,
		XV_DEPTH, depth,
	        XV_VISUAL_CLASS, vis_class,
		CANVAS_RETAINED, FALSE,
		CANVAS_REPAINT_PROC, repaint_print_preview,
		CANVAS_X_PAINT_WINDOW, TRUE,
		CANVAS_PAINTWINDOW_ATTRS,
			WIN_CURSOR, cursor->pan_cursor,
			WIN_TRANSPARENT,
			WIN_EVENT_PROC, print_preview_pan,
			WIN_CONSUME_EVENTS,
				LOC_DRAG, WIN_MOUSE_BUTTONS, 
				NULL,
			NULL,
		XV_HELP_DATA, "imagetool:PrintPreviewCanvas",
		NULL);
	/*
	 * This line is here for backwards compatibility. It will be
	 * removed for the next release.
	 */

	xv_set(canvas_paint_window(obj), XV_KEY_DATA, INSTANCE, ip, NULL);

/*
 *  Get the current list of windows that need colormaps installed (that olwm 
 *  knows about) and add this one to it.
 */
        win = xv_get (canvas_paint_window (obj), XV_XID);
	wins = (Window **) malloc (sizeof (Window *));
        XGetWMColormapWindows (image_display->xdisplay,
                               xv_get(base_window->base_window, XV_XID),
                               wins, &count);
 
	new_wins = (Window *) malloc (sizeof (Window) * (count + 1));
        for (i = 0; i < count; i++)
            new_wins [i] = wins [0][i];
 
        new_wins [count++] = win;
/*
        XSetWMColormapWindows (image_display->xdisplay,
                               xv_get(base_window->base_window, XV_XID),
                               new_wins, count);
*/

	free (new_wins);
	free (wins);
	return obj;
}

/*
 * Create object `controls' in the specified instance.
 */
Xv_opaque
print_prev_controls_create (ip, owner)
	PrintPreviewObjects	*ip;
	Xv_opaque		 owner;
{
	Xv_opaque	obj;
	
/*	obj = xv_create(owner, PANEL, */
	obj = xv_get (owner, FRAME_CMD_PANEL);

	xv_set (obj,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 0,
		XV_Y, (int)xv_get(ip->page, XV_Y) +
		      (int)xv_get(ip->page, XV_HEIGHT),
		XV_WIDTH, WIN_EXTEND_TO_EDGE,
		XV_HEIGHT, WIN_EXTEND_TO_EDGE,
		WIN_BORDER, FALSE,
		XV_HELP_DATA, "imagetool:PrintPreviewWindow",
		NULL);
	return obj;
}

/*
 * Print callback (pops open print pop up)
 */

void
pop_open_print (item, event)
Panel_item	 item;
Event		*event;
{

    if (printer_exists () == TRUE) {
       if (print == (PrintObjects *) NULL) {
          print = PrintObjectsInitialize (NULL, base_window->base_window);
          ds_position_popup (print_preview->print_prev, print->print,
			     DS_POPUP_LOR);
   
          if (current_display == ps_display)
	     set_ps_print_options ();
          else 
	     set_image_print_options ();
   
          update_margins ();
          }

       xv_set (print->print, XV_SHOW, TRUE,
                             NULL);
       }
}

/*
 * Create object `print' in the specified instance.
 */
Xv_opaque
print_prev_print_create (ip, owner)
	PrintPreviewObjects	*ip;
	Xv_opaque		 owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 184,
		XV_Y, xv_row (owner, 0),
		PANEL_LABEL_STRING, LGET ("Print..."),
		PANEL_NOTIFY_PROC, pop_open_print,
		XV_HELP_DATA, "imagetool:PrintPreviewPrint",
		NULL);
	return obj;
}

/*
 * Cancel function.
 */

void
cancel_printprev (item, event)
Panel_item	 item;
Event		*event;
{
    xv_set (print_preview->print_prev, FRAME_CMD_PUSHPIN_IN, FALSE,
				       XV_SHOW, FALSE, 
				       NULL);
}

/*
 * Create object `cancel' in the specified instance.
 */
Xv_opaque
print_prev_cancel_create (ip, owner)
	PrintPreviewObjects	*ip;
	Xv_opaque		 owner;
{
	Xv_opaque	obj;
	
	obj = xv_create(owner, PANEL_BUTTON,
		XV_KEY_DATA, INSTANCE, ip,
		XV_X, 184,
		XV_Y, xv_row (owner, 0),
		PANEL_LABEL_STRING, LGET ("Cancel"),
		PANEL_NOTIFY_PROC, cancel_printprev,
		XV_HELP_DATA, "imagetool:PrintPreviewCancel",
		NULL);
	return obj;
}

void 
resize_print_prev (ip, xpages, ypages, width, height)
	PrintPreviewObjects	*ip;
	int	 		 xpages;
	int	 		 ypages;
	float			 width;
	float			 height;
{
    int print_width;
    int print_height;
    int panel_width;
    int cancel_width;
    int new_width;
    int canvas_width = (int) (xpages * width * PRINT_PREVIEW_PAGE_FACTOR);
    int canvas_height = (int) (ypages * height * PRINT_PREVIEW_PAGE_FACTOR);

    xv_set (ip->page, XV_WIDTH, 	canvas_width,
		      XV_HEIGHT, 	canvas_height,
	 	      CANVAS_HEIGHT,	canvas_height,
		      CANVAS_WIDTH,	canvas_width,
		      NULL);

    print_height = xv_get (ip->print, XV_HEIGHT) + 20;

    cancel_width = xv_get (ip->cancel, XV_WIDTH);
    print_width = xv_get (ip->print, XV_WIDTH);
    new_width = canvas_width;
    if ((print_width + cancel_width + 40) > canvas_width)
       new_width = print_width + cancel_width + 40;

    xv_set (ip->controls, XV_Y,      canvas_height,
			  XV_WIDTH,  new_width,
			  XV_HEIGHT, print_height,
			  NULL);

    xv_set (ip->print, XV_X, 
			   ((new_width - print_width - cancel_width - 20) / 2), 
		       XV_Y, 10,
		       NULL);

    xv_set (ip->cancel, XV_X, xv_get (ip->print, XV_X) +
			      xv_get (ip->print, XV_WIDTH) + 20,
			XV_Y, 10,
			NULL);

    if (new_width > canvas_width)
       xv_set (ip->page, XV_X, (new_width - canvas_width) / 2, NULL);

    xv_set (ip->print_prev, 
		XV_WIDTH, new_width,
		XV_HEIGHT, print_height + canvas_height,
		NULL);

    create_xil_objs (ip);
}

